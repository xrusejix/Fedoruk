<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
   <TITLE>Многопоточное программирование</TITLE>
</HEAD>
<BODY>

<CENTER><H3>
Задания к лабораторной работе по многопоточному программированию
</H3></CENTER>
Требования к отчету по лабораторной работе приведены в <A
HREF="#report">конце страницы</A>.
<BR><BR>
<B>Внимание!</B> Разработанные программы, решающие дифференциальные 
уравнения, должны демонстрировать работоспособность в 
&quot;неграфическом&quot; режиме для пространственных 
сеток размерностью не менее 10000000 узлов для тысяч временных
слоев.<BR><BR>

<B>Внимание!</B> Для обеспечения высокой производительности параллельных
программ необходимо минимизировать накладные расходы, связанные с
порождением и завершением потоков управления. А это значит, что потоки,
многократно реализующие одну и ту же функцию (например, исключающие
ненулевые элементы в строке/столбце в прямом ходе метода Гаусса), должны
запускаться однократно.<BR><BR>

1<SUP>**</SUP>. Разработать, используя средства многопотокового программивания, параллельную
программу имитационного моделирования (микромини-GPSS) систем массового
обслуживания в режиме, приближенном к режиму реального времени (здесь не
имеется в виду режим реального времени, поддерживаемый ОС).
<BR>Допустимые элементы СМО - генератор транзакций (ГТ), обслуживающий
аппарат (ОА), очередь (ОЧ), разветвитель (РВ). Каждый элемент имеет 1 вход
(кроме ГТ). Каждый выход элемента может быть нагружен только на один вход
другого (единственного) элемента. Точки соединения элементов друг с другом
называются узлами. К узлу может быть подключено <I>любое</I> количество
выходов элементов, но только <I>один</I> вход. Для выходов элементов узел
играет роль соединителя (объединителя в один поток) транзакций.
<BR>Все параметры времени являются целыми числами, задающими количество
секунд. Случайные величины имеют равномерный закон распределения от заданного
минимального значения до заданного максимального значения.
<BR>Узлы СМО (точки соединения элементов друг с другом) нумеруются строго
последовательными целыми числами, начиная с 0. Транзакции помечаются целыми
положительными числами (0 играет роль признака отсутствия транзакции в
узле).
<UL>
<LI>
ГТ имеет 1 выход, 2 параметра (мин и макс значения интервала между двумя
транзакциями). Если в момент генерации очередной транзакции принимающий
элемент занят, то ... (предложить и реализовать 2 варианта поведения).</LI>

<LI>
ОА имеет 1 вход и 1 выход, 2 параметра (мин и макс значения времени обработки
транзакции). Способен обрабатывать транзакции только поочередно. Если элемент-приемник,
подключенный к выходу ОА занят обработкой какой-либо др. транзакции, то
ОА блокируется (переходит в состояние ожидания) точно до момента освобождения
приемника. Если в момент освобождения ОА (передачи транзакции на обработку
элементу-приемнику) на его входе нет транзакции, то ОА впадает в спячку
точно до момента появления транзакции от одного из источников.</LI>

<LI>
ОЧ имеет 1 вход и 1 выход, 1 параметр (макс допустимый размер). Накапливает
транзакции в ситуации, когда ее приемник (обычно это ОА) занят. При свободном
приемнике передает ему транзакцию без задержки.</LI>

<LI>
РВ имеет 1 вход и 2 выхода, 1 параметр (вероятность передачи транзакции
на первый выход). Передает без задержки транзакцию с входа на первый выход
с заданной в качестве параметра вероятностью, иначе - на второй выход.
Если необходимый приемник занят, то РВ от элемента-источника транзакцию
не принимает и ждет освобождения элемента-приемника.</LI>
</UL>
Методические указания.
<UL>
<LI>
Для моделирования поведения каждого элемента СМО (ГТ, ОА, ОЧ и РВ) разработать
собственную функцию.</LI>

<LI>
Для моделирования поведения каждого <I>экземпляра</I> элемента СМО программа
должна запускать отдельный поток управления для соответствующей функции.</LI>

<LI>
Временные задержки в элементах ГТ и ОА реализовать в 2-ух вариантах: с
помощью функции sleep и через вычислительный цикл.</LI>

<LI>
Для синхронизации работы элементов рекомендуется (но не диктуется) использовать
взаимоисключающие блокировки и условные переменные, а для организации ожидания
транзакции на входе элемента - функции sigwait и pthread_kill (см. примеры
в лекциях).</LI>

<LI>
Для хранения информации о структуре СМО рекомендуется создать (в глобальной
памяти) массив размерностью n структур smo_node, где n - количество узлов
в СМО.</LI>

<PRE>struct smo_node {</PRE>

<PRE>    int    tr_num;  // номер транзакции в узле (0 - пусто)</PRE>

<PRE>    pthread_t tid;  // идентификатор потока - приемника транзакции</PRE>

<PRE>    pthread_mutex_t mutx;</PRE>

<PRE>    pthread_cond_t condx;</PRE>

<PRE>    };</PRE>

<PRE>struct smo_node smo[n];</PRE>

<LI>
Для заданной преподавателем СМО программа должна запускать на выполнение
в качестве отдельных потоков необходимые функции (моделирующие поведение
элементов СМО) и заполнять массив smo. Этим функциям в качестве аргументов
должны передаваться параметры (см. выше) и индексы в массиве smo узла-входа
(кроме ГТ) и узла-выхода (а для РВ и индекс второго узла-выхода).</LI>

<LI>
Возможно, для унификации механизма обработки транзакций потребуется самостоятельно
разработать и реализовать дополнительный элемент - уничтожитель транзакций
на выходе из СМО. Тщательно продумать данный вопрос.</LI>

<LI>
Предложить и реализовать удобный способ вывода информации об обработке
транзакций в СМО.</LI>

<LI>
Студент обязан явиться на лаб. работу с готовыми (лучше, отлаженными) текстами
функций, моделирующих поведение элементов. Для отладки СМО сочинить самостоятельно,
включив в нее повторяющиеся элементы и петли возврата транзакций.</LI>
</UL>

2<SUP>**</SUP>. Разработать, используя средства многопотокового программирования, параллельную
программу асинхронного двоичного моделирования логических схем с учетом
задержек распространения сигналов на элементах.
<BR>Допустимые элементы: 2И, 2И-НЕ, 2ИЛИ, 2ИЛИ-НЕ, НЕ, ГС (генератор логического
сигнала). Важно, что все элементы имеют только <I>один</I> выход, однако
сигнал с этого выхода может поступать на входы многих элементов. Монтажное
ИЛИ недопустимо. Единственным параметром всех элементов является целочисленная
задержка распространения сигнала на элементе (в <I>секундах</I> !!!). ГС
в качестве параметра принимает список (неопределенной длины) моментов переключения
сигнала, начиная с уровня логического нуля.

<P>Методические указания.
<UL>
<LI>
<I>Творчески</I> ориентироваться на методические указания к заданию 1,
проанализировав разницу в функционировании СМО и логической схемы.</LI>

<LI>
Тщательно проработать методы решения проблемы "коротких" входных импульсов,
т.е. импульсов длительностью меньше  задержки элемента.</LI>
</UL>
<BR><BR>

3<SUP>*</SUP>. Разработать, используя средства многопотокового программирования, параллельную
программу решения методом Гаусса системы линейных алгебраических уравнений
(СЛАУ), матрица коэффициентов которой имеет 
<A HREF="#diag_matrix">блочно-диагональный с окаймлением</A> вид.
В качестве тестовых использовать реальные матрицы из
<A HREF="http://math.nist.gov/MatrixMarket">хранилища</A>
или самостоятельно генерировать тестовую СЛАУ описанным ниже 
<A HREF="#gen_les">способом</A>. 
Размер диагонального блока, ширина окаймления, количество параллельно
выполняющихся потоков - аргументы программы.
См. также <A HREF="#matrix">замечание<A>.
Программа должна демонстрировать <A HREF="#par_effect">ускорение<A>
по сравнению с последовательным вариантом.
<BR><BR>

4<SUP>*</SUP>. Разработать, используя средства многопотокового программирования, параллельную
программу решения методом Гаусса системы линейных алгебраических уравнений
без учета разреженности матрицы коэффициентов.
Параллельные потоки (их количество - аргумент
программы) ведут исключение элементов в прямом ходе по
<B><I>столбцам</I></B>.
В качестве тестовых использовать реальные матрицы из
<A HREF="http://math.nist.gov/MatrixMarket">хранилища</A>
или самостоятельно генерировать тестовую СЛАУ описанным ниже 
<A HREF="#gen_les">способом</A>.
См. также <A HREF="#matrix">замечание<A>.
Программа должна демонстрировать <A HREF="#par_effect">ускорение<A>
по сравнению с последовательным вариантом.
Предусмотреть возможность диагностического вывода структуры матрицы
коэффициентов в течение прямого хода метода Гаусса.
Отчет должен содержать подробное (иллюстрированное картинками) описание
использованного способа распараллеливания и синхронизации.
<BR><BR>

5<SUP>*</SUP>. Разработать, используя средства многопотокового программирования, параллельную
программу решения методом Гаусса системы линейных алгебраических уравнений
без учета разреженности матрицы коэффициентов.
Параллельные потоки (их количество - аргумент
программы) ведут исключение элементов в прямом ходе по <B><I>строкам</I></B>.
В качестве тестовых использовать реальные матрицы из
<A HREF="http://math.nist.gov/MatrixMarket">хранилища</A>
или самостоятельно генерировать тестовую СЛАУ описанным ниже 
<A HREF="#gen_les">способом</A>.
См. также <A HREF="#matrix">замечание<A>.
Программа должна демонстрировать <A HREF="#par_effect">ускорение<A>
по сравнению с последовательным вариантом.
Предусмотреть возможность диагностического вывода структуры матрицы
коэффициентов в течение прямого хода метода Гаусса.
Отчет должен содержать подробное (иллюстрированное картинками) описание
использованного способа распараллеливания и синхронизации.
<BR><BR>

6. Разработать, используя средства многопотокового программирования, параллельную
программу решения одномерной нестационарной краевой задачи методом конечных
разностей (МКР) с использованием <I>явной</I> вычислительной схемы.
<A NAME=mthread6>
<P>Дан цилиндрический стержень длиной L и площадью поперечного сечения
S. Цилиндричекая поверхность стержня теплоизолирована. На торцевых поверхностях
стержня слева и справа могут иметь место граничные условия первого, второго
или третьего
родов. Распределение поля температур по длине стержня описывается уравнением
теплопроводности

<P>dT/dt = a<SUB>T</SUB>*d<SUP>2</SUP>T/dx<SUP>2</SUP>+g<SUB>T</SUB>

<P>, где

<P>a<SUB>T</SUB>=lambda/(C<SUB>T</SUB>*p) - коэффициент температуропроводности;

<P>lambda - коэффициент теплопроводности среды;

<P>C<SUB>T</SUB> - удельная теплоемкость единицы массы;

<P>p - плотность среды;

<P>g<SUB>T</SUB>=G<SUB>T</SUB>/(C<SUB>T</SUB>*p) - приведенная скорость
взаимного превращения тепловой энергии в другие виды энергии, в нашем случае
g<SUB>T</SUB>=0.

<P>В явной вычислительной схеме МКР для аппроксимации производной температуры
по времени в узле, принадлежащем i-ому временному и j-ому пространственному
слоям, используется &quot;разница вперед&quot;:

<P>dT/dt|<SUP>i</SUP><SUB>j</SUB> = (T<SUP>i+1</SUP><SUB>j</SUB>-T<SUP>i</SUP>
<SUB>j</SUB>)/h<SUB>t</SUB><BR>
, где h<SUB>t</SUB> - шаг дискретизации по оси времени.

<P>Для аппроксимации второй производной температуры по пространственной
координате x используется &quot;центральная разница&quot;:

<P>d<SUP>2</SUP>T/dx<SUP>2</SUP>|<SUP>i</SUP><SUB>j</SUB> = (T<SUP>i</SUP><SUB>j
+1</SUB>-2*T<SUP>i</SUP><SUB>j</SUB>+T<SUP>i</SUP><SUB>j-1</SUB>)/h<SUB>x</SUB>
<SUP>2</SUP><BR>
, где h<SUB>x</SUB> - шаг дискретизации по пространственной координате.

<P>Тогда алгебраизированное уравнение теплопроводности для узла, принадлежащего
i-ому временному и j-ому пространственному слоям, принимает следующий вид
(g<SUB>T</SUB>=0):

<P>(T<SUP>i+1</SUP><SUB>j</SUB>-T<SUP>i</SUP><SUB>j</SUB>)/h<SUB>t</SUB>
= a<SUB>T</SUB>*(T<SUP>i</SUP><SUB>j+1</SUB>-2*T<SUP>i</SUP><SUB>j</SUB>+T<SUP>i
</SUP><SUB>j-1</SUB>)/h<SUP>2</SUP><SUB>x</SUB>

<P>Такой вид уравнения позволяет в <I>явном</I> виде выразить единственную
неизвестную:

<P>T<SUP>i+1</SUP><SUB>j</SUB> = a<SUB>T</SUB>*(T<SUP>i</SUP>
<SUB>j+1</SUB>-2*T<SUP>i</SUP><SUB>j</SUB>+T<SUP>i</SUP>
<SUB>j-1</SUB>)*h<SUB>t</SUB>/h<SUP>2</SUP><SUB>x</SUB>+T<SUP>i</SUP><SUB>j</SUB
>

<P>Что, в свою очередь, дает возможность просто организовать вычислительный
процесс в виде &quot;цикл в цикле&quot; (без деталей, связанных с граничными 
условиями различного рода):
<PRE>for (i=0; i&lt;n; i++)
&nbsp; for (j=0; j&lt;m; j++)
&nbsp;&nbsp;&nbsp; T<SUP>i+1</SUP><SUB>j</SUB> = ...</PRE>
Напомним, что значения T<SUP>0</SUP><SUB>j</SUB> известны из начальных
условий. Здесь n=T<SUB>кон</SUB>/h<SUB>t</SUB>, m - количество
пространственных слоёв расчетной сетки.

<P>Требуется разработать параллельную программу, в которой каждый поток
управления
ответственнен за расчеты для &quot;полосы&quot; расчетной сетки шириной в m/N 
пространственных узлов, где N - число потоков управления. 
Программа должна демонстрировать <A HREF="#par_effect">ускорение<A>
по сравнению с последовательным вариантом.
Предусмотреть визуализацию результатов посредством утилиты gnuplot.
<P>Методические указания.
<BR>&nbsp;
<UL>
<LI>
Тщательно (лучше графически, используя шаблон разностной схемы) проанализировать
работу последовательного (непараллельного) алгоритма.</LI>

<LI>
Обеспечить возможность запуска программы для произвольного числа потоков
управления
N и произвольного количества пространственных слоев m (допустимо, чтобы
m было кратно N).</LI>

<LI>
Вид граничных условий и численные значения параметров стержня для конкретного
варианта задания получить у преподавателя.</LI>

<LI>
Для визуализации результатов решения задачи идеально подходит стандартная
для UNIX рутина gnuplot [<A HREF="http://www.duke.edu/~hpgavin/gnuplot.html">
http://www.duke.edu/~hpgavin/gnuplot.html</A>].</LI>

<LI>
Свойства некоторых материалов представлены в таблице.
<TABLE ALIGN=CENTER BORDER CELLSPACING=2>
<TR><TH>Материал</TH>
<TH>Плотность<BR>кг/м<SUP>3</SUP></TH>
<TH>Удельная<BR>теплоемкость<BR>дж/(кг*град)</TH>
<TH>Коэффициент<BR>теплопроводности<BR>вт/(м*град)</TH></TR>
<TR><TD>Алюминий</TD><TD ALIGN=RIGHT>2700</TD>
<TD ALIGN=RIGHT>880</TD><TD ALIGN=RIGHT>210</TD></TR>
<TR><TD>Дерево</TD><TD ALIGN=RIGHT>500</TD>
<TD ALIGN=RIGHT>1700</TD><TD ALIGN=RIGHT>0.4</TD></TR>
<TR><TD>Золото</TD><TD ALIGN=RIGHT>19300</TD>
<TD ALIGN=RIGHT>130</TD><TD ALIGN=RIGHT>313</TD></TR>
<TR><TD>Медь</TD><TD ALIGN=RIGHT>8900</TD>
<TD ALIGN=RIGHT>390</TD><TD ALIGN=RIGHT>390</TD></TR>
<TR><TD>Серебро</TD><TD ALIGN=RIGHT>10500</TD>
<TD ALIGN=RIGHT>235</TD><TD ALIGN=RIGHT>420</TD></TR>
<TR><TD>Сталь</TD><TD ALIGN=RIGHT>7800</TD>
<TD ALIGN=RIGHT>460</TD><TD ALIGN=RIGHT>45</TD></TR>
</TABLE>
<I>Примечание.</I> Отладку программы рекомендуется начать, положив
a<SUB>T</SUB>=1,0.
</LI>
</UL>
<BR>

7<SUP>*</SUP>. Разработать, используя средства многопотокового программирования, параллельную
программу решения одномерной нестационарной краевой задачи методом конечных
разностей с использованием <I>неявной</I> вычислительной схемы.
Постановка задачи описаны <A HREF="#mthread6">выше</A>.
<P>В неявной вычислительной схеме МКР для аппроксимации производной температуры
по времени в узле, принадлежащем i-ому временному и j-ому пространственному
слоям, используется &quot;разница назад&quot;:

<P>dT/dt|<SUP>i</SUP><SUB>j</SUB> = (T<SUP>i</SUP><SUB>j</SUB>-T<SUP>i-1</SUP>
<SUB>j</SUB>)/h<SUB>t</SUB><BR>
, где h<SUB>t</SUB> - шаг дискретизации по оси времени.

<P>Для аппроксимации второй производной температуры по пространственной
координате x используется &quot;центральная разница&quot;:

<P>d<SUP>2</SUP>T/dx<SUP>2</SUP>|<SUP>i</SUP><SUB>j</SUB> = (T<SUP>i</SUP><SUB>j
+1</SUB>-2*T<SUP>i</SUP><SUB>j</SUB>+T<SUP>i</SUP><SUB>j-1</SUB>)/h<SUB>x</SUB>
<SUP>2</SUP><BR>
, где h<SUB>x</SUB> - шаг дискретизации по пространственной координате.

<P>Тогда алгебраизированное уравнение теплопроводности для узла, принадлежащего
i-ому временному и j-ому пространственному слоям, принимает следующий вид
(g<SUB>T</SUB>=0):

<P>(T<SUP>i</SUP><SUB>j</SUB>-T<SUP>i-1</SUP><SUB>j</SUB>)/h<SUB>t</SUB>
= a<SUB>T</SUB>*(T<SUP>i</SUP><SUB>j+1</SUB>-2*T<SUP>i</SUP><SUB>j</SUB>+T<SUP>i
</SUP><SUB>j-1</SUB>)/h<SUP>2</SUP><SUB>x</SUB>

<P>Это уравнение содержит три неизвестные T<SUP>i</SUP><SUB>j-1</SUB>,
T<SUP>i</SUP><SUB>j</SUB> и T<SUP>i</SUP><SUB>j+1</SUB>, 
относящиеся к текущему (i-ому) временному слою.
Для отыскания всех неизвестных T<SUP>i</SUP><SUB>j</SUB>, j=1...m,
для каждого временного слоя необходимо решать систему линейных
алгебраических уравнений вида:<BR>

T<SUP>i</SUP><SUB>j+1</SUB>-(2+b)*T<SUP>i</SUP><SUB>j</SUB>
+T<SUP>i</SUP><SUB>j-1</SUB>=b*T<SUP>i</SUP><SUB>j</SUB><BR>
, где b=h<SUP>2</SUP><SUB>x</SUB>/(a<SUB>T</SUB>*h<SUB>t</SUB>).

<P><I>Примечание.</I> Использование неявной вычислительной схемы
связано с решением системы ЛАУ на каждом временн<B>о</B>м слое.
Следовательно, распараллеливание решения краевой задачи неявным методом
сводится к распараллеливанию решения системы ЛАУ методом Гаусса.
Распараллеливание же метода Гаусса проще всего реализуется в ситуации,
когда матрица коэффициентов системы имеет 
<A HREF="#diag_matrix">блочно-диагональный с окаймлением</A> вид.
Матрица же коэффициентов автоматически получит такой вид, если
нумерацию узлов расчетной сетки вести по такой простой схеме:
сначала &quot;внутренние&quot; узлы всех фрагментов, на которые
разбивается стержень, а в последнюю очередь -
&quot;соединительные&quot; узлы. Кстати, сказанное выше справедливо
и для метода прогонки (поскольку этот метод - частный случай метода
Гаусса).
См. также <A HREF="#matrix">замечание<A>.
Программа должна демонстрировать <A HREF="#par_effect">ускорение<A>
по сравнению с последовательным вариантом. Обеспечить возможность 
запуска программы для произвольного числа потоков управления
N и произвольного количества пространственных слоев m (допустимо, чтобы
m было кратно N).
<BR><BR>

8. Разработать, используя средства многопотокового программирования, параллельную
программу решения двумерной <I>нестационарной</I> краевой задачи методом конечных
разностей с использованием явной вычислительной схемы. Объект моделирования -
прямоугольная пластина постоянной толщины.
Подробности постановки подобной задачи даны <A HREF="#mthread6">выше</A>.
Возможны граничные условия первого и второго рода в различных
узлах расчетной сетки.
Количество потоков, временной интервал моделирования и количество
узлов расчетной сетки
- параметры программы.
См. также <A HREF="#matrix">замечание<A>.
Программа должна демонстрировать <A HREF="#par_effect">ускорение<A>
по сравнению с последовательным вариантом.
Предусмотреть визуализацию результатов посредством утилиты gnuplot.
<BR><BR>

9<SUP>*</SUP>. Разработать, используя средства многопотокового программирования, параллельную
программу решения двумерной <I>стационарной</I> краевой задачи методом конечных
разностей. Объект моделирования - прямоугольная пластина постоянной толщины.
Возможны граничные условия первого и второго рода в различных
узлах расчетной сетки.
Количество потоков и количество узлов расчетной сетки - параметры программы.
Подробности постановки задачи выяснить у преподавателя.
Предусмотреть визуализацию результатов посредством утилиты gnuplot.
<BR>
<I>Примечание.</I> Распараллеливание решения стационарной краевой задачи
сводится к распараллеливанию решения системы ЛАУ методом Гаусса (или
его частным случаем - методом прогонки).
Распараллеливание метода Гаусса проще всего реализуется в ситуации,
когда матрица коэффициентов системы имеет 
<A HREF="#diag_matrix">блочно-диагональный с окаймлением</A> вид.
Матрица же коэффициентов автоматически получит такой вид, если
нумерацию узлов расчетной сетки вести по такой простой схеме:
сначала &quot;внутренние&quot; узлы всех фрагментов, на которые
разбивается пластина, а в последнюю очередь -
&quot;соединительные&quot; узлы.
См. также <A HREF="#matrix">замечание<A>.
Программа должна демонстрировать <A HREF="#par_effect">ускорение<A>
по сравнению с последовательным вариантом.
<BR><BR>

10. Разработать многопотоковый вариант программы моделирования лифтовой системы (см.
задание 8 из лаб. работы 1). При этом модели БН, ЛП и ЛГ выполняются в рамках
отдельных потоков программы.
<BR><BR>

11. Разработать многопотоковый вариант программы моделирования
распространения электрических сигналов в линейной цепочке RC-элементов
(см. рис. ниже). Метод формирования математической модели - узловой. Метод
численного интегрирования - <B>явный</B> Эйлера. Внешнее воздействие - источники
тока и напряжения. Количество потоков, временной интервал моделирования и
количество элементов в цепочке - параметры программы.
Программа должна демонстрировать <A HREF="#par_effect">ускорение<A>
по сравнению с последовательным вариантом.
Предусмотреть визуализацию результатов посредством утилиты gnuplot.
<CENTER><IMG SRC="unixprog1.png"></CENTER>
<I>Примечание.</I> Узловой метод для формирования математической модели системы использует
второй закон Кирхгофа - сумма токов в узле равна нулю.
В данном задании для каждого j-ого узла цепочки уравнение баланса токов
имеет вид<BR>
I<SUB>Rлев</SUB>-I<SUB>Rправ</SUB>-I<SUB>C</SUB>=0 или
(V<SUP>i</SUP><SUB>j-1</SUB>-V<SUP>i</SUP><SUB>j</SUB>)/R-(V<SUP>i</SUP><SUB>j</SUB>-V<SUP>i</SUP><SUB>j+1</SUB>)/R-C*dV<SUP>i</SUP><SUB>j</SUB>/dt=0,
где i - номер врем<B>е</B>нного шага, V - потенциал узла.<BR>
В <B>явном</B> методе Эйлера для аппроксимации производной по времени
используется выражение
dV<SUP>i</SUP><SUB>j</SUB>/dt=(V<SUP>i+1</SUP><SUB>j</SUB>-V<SUP>i</SUP><SUB>j</SUB>)/h,
где h - шаг численного интегрирования.<BR>
В <B>неявном</B> методе Эйлера аппроксимация иная -
dV<SUP>i</SUP><SUB>j</SUB>/dt=(V<SUP>i</SUP><SUB>j</SUB>-V<SUP>i-1</SUP><SUB>j</SUB>)/h.
<BR><BR>

12<SUP>*</SUP>. Разработать многопотоковый вариант программы моделирования
распространения электрических сигналов в линейной цепочке RC-элементов
(см. рисунок и примечание выше). Метод формирования математической модели - узловой. Метод
численного интегрирования - <B>неявный</B> Эйлера. Внешнее воздействие - источники
тока и напряжения. Количество потоков, временной интервал моделирования и
количество элементов в цепочке - параметры программы.
Программа должна демонстрировать <A HREF="#par_effect">ускорение<A>
по сравнению с последовательным вариантом.
Предусмотреть визуализацию результатов посредством утилиты gnuplot.
<BR>
<I>Примечание.</I> Использование неявного метода Эйлера
связано с решением системы ЛАУ на каждом временн<B>о</B>м шаге.
Следовательно, распараллеливание решения задачи численного интегрирования
 неявным методом
сводится к распараллеливанию решения системы ЛАУ методом Гаусса.
Распараллеливание же метода Гаусса проще всего реализуется в ситуации,
когда матрица коэффициентов системы имеет 
<A HREF="#diag_matrix">блочно-диагональный с окаймлением</A> вид.
Матрица же коэффициентов автоматически получит такой вид, если
нумерацию узлов расчетной сетки вести по такой простой схеме:
сначала &quot;внутренние&quot; узлы всех фрагментов, на которые
разбивается цепочка элементов, а в последнюю очередь -
&quot;соединительные&quot; узлы.
См. также <A HREF="#matrix">замечание<A>.
<BR><BR>

13. Разработать многопотоковый вариант программы моделирования
распространения электрических сигналов в двухмерной прямоугольной сетке RC-элементов
(одномерный аналог которых представлен на рис. выше). Метод формирования
математической модели - узловой. Метод
численного интегрирования - <B>явный</B> Эйлера. Внешнее воздействие - источники
тока и напряжения. Количество потоков, временной интервал моделирования и
количество элементов в сетке - параметры программы.
Программа должна демонстрировать <A HREF="#par_effect">ускорение<A>
по сравнению с последовательным вариантом.
Предусмотреть визуализацию результатов посредством утилиты gnuplot.
<BR><BR>

14<SUP>*</SUP>. Разработать многопотоковый вариант программы моделирования
распространения электрических сигналов в двухмерной прямоугольной сетке RC-элементов
(одномерный аналог которых представлен на рис. выше). Метод формирования
математической модели - узловой. Метод
численного интегрирования - <B>неявный</B> Эйлера. Внешнее воздействие - источники
тока и напряжения. Количество потоков, временной интервал моделирования и
количество элементов в сетке - параметры программы.
Программа должна демонстрировать <A HREF="#par_effect">ускорение<A>
по сравнению с последовательным вариантом.
Предусмотреть визуализацию результатов посредством утилиты gnuplot.
<BR>
<I>Примечание.</I> Использование неявного метода Эйлера
связано с решением системы ЛАУ на каждом временн<B>о</B>м шаге.
Следовательно, распараллеливание решения задачи численного интегрирования
неявным методом
сводится к распараллеливанию решения системы ЛАУ методом Гаусса.
Распараллеливание же метода Гаусса проще всего реализуется в ситуации,
когда матрица коэффициентов системы имеет 
<A HREF="#diag_matrix">блочно-диагональный с окаймлением</A> вид.
Матрица же коэффициентов автоматически получит такой вид, если
нумерацию узлов расчетной сетки вести по такой простой схеме:
сначала &quot;внутренние&quot; узлы всех фрагментов, на которые
разбивается сетка, а в последнюю очередь -
&quot;соединительные&quot; узлы.
См. также <A HREF="#matrix">замечание<A>.
<BR><BR>

15<SUP>*</SUP>. Разработать многопотоковый вариант программы моделирования
распространения электрических сигналов в линейной цепочке LC-элементов
(см. рис. ниже). Метод формирования математической модели - узловой. Метод  
численного интегрирования - неявный Эйлера. Внешнее воздействие - источники 
тока и напряжения. Количество потоков, временной интервал моделирования и
количество элементов в цепочке - параметры программы.
Программа должна демонстрировать <A HREF="#par_effect">ускорение<A>
по сравнению с последовательным вариантом.
Предусмотреть визуализацию результатов посредством утилиты gnuplot.
<BR>
<I>Примечание.</I> Использование неявного метода Эйлера
связано с решением системы ЛАУ на каждом временн<B>о</B>м шаге.
Следовательно, распараллеливание решения задачи численного интегрирования
неявным методом
сводится к распараллеливанию решения системы ЛАУ методом Гаусса.
Распараллеливание же метода Гаусса проще всего реализуется в ситуации,
когда матрица коэффициентов системы имеет 
<A HREF="#diag_matrix">блочно-диагональный с окаймлением</A> вид.
Матрица же коэффициентов автоматически получит такой вид, если
нумерацию узлов цепочки элементов вести по такой простой схеме:
сначала &quot;внутренние&quot; узлы всех фрагментов, на которые
разбивается цепочка элементов, а в последнюю очередь -
&quot;соединительные&quot; узлы.
См. также <A HREF="#matrix">замечание<A>.
<CENTER><IMG SRC="unixprog2.png"></CENTER>
<BR><BR>

16<SUP>*</SUP>. Разработать многопотоковый вариант программы моделирования
распространения электрических сигналов в двухмерной прямоугольной сетке LC-элементов
(одномерный аналог которых представлен на рис. выше). Метод формирования
математической модели - узловой. Метод
численного интегрирования - неявный Эйлера. Внешнее воздействие - источники
тока и напряжения. Количество потоков, временной интервал моделирования и
количество элементов в сетке - параметры программы.
Программа должна демонстрировать <A HREF="#par_effect">ускорение<A>
по сравнению с последовательным вариантом.
Предусмотреть визуализацию результатов посредством утилиты gnuplot.
<BR>
<I>Примечание.</I> Использование неявного метода Эйлера
связано с решением системы ЛАУ на каждом временн<B>о</B>м шаге.
Следовательно, распараллеливание решения задачи численного интегрирования
неявным методом
сводится к распараллеливанию решения системы ЛАУ методом Гаусса.
Распараллеливание же метода Гаусса проще всего реализуется в ситуации,
когда матрица коэффициентов системы имеет 
<A HREF="#diag_matrix">блочно-диагональный с окаймлением</A> вид.
Матрица же коэффициентов автоматически получит такой вид, если
нумерацию узлов сетки вести по такой простой схеме:
сначала &quot;внутренние&quot; узлы всех фрагментов, на которые
разбивается сетка, а в последнюю очередь -
&quot;соединительные&quot; узлы.
См. также <A HREF="#matrix">замечание<A>.
<BR><BR>

17<SUP>*</SUP>. Разработать многопотоковый вариант программы моделирования
распространения электрических сигналов в линейной цепочке RLC-элементов
(см. рис. ниже). Метод формирования математической модели - узловой. Метод
численного интегрирования - неявный Эйлера. Внешнее воздействие - источники
тока и напряжения. Количество потоков, временной интервал моделирования и
количество элементов в цепочке - параметры программы.
Программа должна демонстрировать <A HREF="#par_effect">ускорение<A>
по сравнению с последовательным вариантом.
Предусмотреть визуализацию результатов посредством утилиты gnuplot.
<BR>
<I>Примечание.</I> Использование неявного метода Эйлера
связано с решением системы ЛАУ на каждом временн<B>о</B>м шаге.
Следовательно, распараллеливание решения задачи численного интегрирования
неявным методом
сводится к распараллеливанию решения системы ЛАУ методом Гаусса.
Распараллеливание же метода Гаусса проще всего реализуется в ситуации,
когда матрица коэффициентов системы имеет 
<A HREF="#diag_matrix">блочно-диагональный с окаймлением</A> вид.
Матрица же коэффициентов автоматически получит такой вид, если
нумерацию узлов цепочки элементов вести по такой простой схеме:
сначала &quot;внутренние&quot; узлы всех фрагментов, на которые
разбивается цепочка элементов, а в последнюю очередь -
&quot;соединительные&quot; узлы.
См. также <A HREF="#matrix">замечание<A>.
<CENTER><IMG SRC="unixprog3.png"></CENTER>
<BR><BR>

18<SUP>*</SUP>. Разработать многопотоковый вариант программы моделирования
распространения электрических сигналов в двухмерной прямоугольной сетке RLC-элементов
(одномерный аналог которых представлен на рис. выше). Метод формирования
математической модели - узловой. Метод
численного интегрирования - неявный Эйлера. Внешнее воздействие - источники
тока и напряжения. Количество потоков, временной интервал моделирования и
количество элементов в сетке - параметры программы.
Программа должна демонстрировать <A HREF="#par_effect">ускорение<A>
по сравнению с последовательным вариантом.
Предусмотреть визуализацию результатов посредством утилиты gnuplot.
<BR>
<I>Примечание.</I> Использование неявного метода Эйлера
связано с решением системы ЛАУ на каждом временн<B>о</B>м шаге.
Следовательно, распараллеливание решения задачи численного интегрирования
неявным методом
сводится к распараллеливанию решения системы ЛАУ методом Гаусса.
Распараллеливание же метода Гаусса проще всего реализуется в ситуации,
когда матрица коэффициентов системы имеет 
<A HREF="#diag_matrix">блочно-диагональный с окаймлением</A> вид.
Матрица же коэффициентов автоматически получит такой вид, если
нумерацию узлов сетки элементов вести по такой простой схеме:
сначала &quot;внутренние&quot; узлы всех фрагментов, на которые
разбивается сетка, а в последнюю очередь -
&quot;соединительные&quot; узлы.
См. также <A HREF="#matrix">замечание<A>.
<BR><BR>

19. Разработать, используя средства многопотокового программирования, параллельную
программу решения уравнения струны методом конечных
разностей с использованием <I>явной</I> вычислительной схемы. Количество потоков,
временной интервал моделирования и количество узлов расчетной сетки -
параметры программы.<BR>
Уравнение струны имеет следующий вид:
<P>d<SUP>2</SUP>z/dt<SUP>2</SUP> = a<SUP>2</SUP>*d<SUP>2</SUP>z/dx<SUP>2</SUP>+f(x,t)
<P>, где t - время, x - пространственная координата, вдоль которой
ориентирована струна, z - отклонение (малое) точки струны от положения
покоя, a - фазовая скорость, f(x,t) - внешнее &quot;силовое&quot;
воздействие на струну.<BR>
Предусмотреть возможность задания ненулевых начальных условий и ненулевого
внешнего воздействия.
Программа должна демонстрировать <A HREF="#par_effect">ускорение<A>
по сравнению с последовательным вариантом.
Предусмотреть визуализацию результатов посредством утилиты gnuplot.
<BR><BR>

20<SUP>*</SUP>. Разработать, используя средства многопотокового программирования, параллельную
программу решения уравнения струны методом конечных
разностей с использованием <I>неявной</I> вычислительной схемы. Количество потоков,
временной интервал моделирования и количество узлов расчетной сетки -
параметры программы.<BR>
Уравнение струны имеет следующий вид:
<P>d<SUP>2</SUP>z/dt<SUP>2</SUP> = a<SUP>2</SUP>*d<SUP>2</SUP>z/dx<SUP>2</SUP>+f(x,t)
<P>, где t - время, x - пространственная координата, вдоль которой
ориентирована струна, z - отклонение (малое) точки струны от положения
покоя, a - фазовая скорость, f(x,t) - внешнее &quot;силовое&quot;
воздействие на струну.<BR>
Предусмотреть возможность задания ненулевых начальных условий и ненулевого
внешнего воздействия.
Программа должна демонстрировать <A HREF="#par_effect">ускорение<A>
по сравнению с последовательным вариантом.
Предусмотреть визуализацию результатов посредством утилиты gnuplot.
<BR>
<I>Примечание.</I> Использование неявной вычислительной схемы
связано с решением системы ЛАУ на каждом временн<B>о</B>м слое.
Следовательно, распараллеливание решения краевой задачи неявным методом
сводится к распараллеливанию решения системы ЛАУ методом Гаусса.
Распараллеливание же метода Гаусса проще всего реализуется в ситуации,
когда матрица коэффициентов системы имеет 
<A HREF="#diag_matrix">блочно-диагональный с окаймлением</A> вид.
Матрица же коэффициентов автоматически получит такой вид, если
нумерацию узлов расчетной сетки вести по такой простой схеме:
сначала &quot;внутренние&quot; узлы всех фрагментов, на которые
разбивается струна, а в последнюю очередь -
&quot;соединительные&quot; узлы. Кстати, сказанное выше справедливо
и для метода прогонки (поскольку этот метод - частный случай метода
Гаусса).
См. также <A HREF="#matrix">замечание<A>.
<BR><BR>

21. Разработать, используя средства многопотокового программирования, параллельную
программу решения уравнения прямоугольной мембраны методом конечных
разностей с использованием <I>явной</I> вычислительной схемы. Количество потоков,
временной интервал моделирования и количество узлов расчетной сетки -
параметры программы.<BR>
Уравнение мембраны имеет следующий вид:
<P>d<SUP>2</SUP>z/dt<SUP>2</SUP> =
a<SUP>2</SUP>*(d<SUP>2</SUP>z/dx<SUP>2</SUP>+d<SUP>2</SUP>z/dy<SUP>2</SUP>)+f(x,y,t)
<P>, где t - время, x, y - пространственные координаты, z - отклонение (малое) 
точки мембраны от положения
покоя, a - фазовая скорость, f(x,y,t) - внешнее &quot;силовое&quot;
воздействие на мембрану перпендикулярное ее плоскости.<BR>
Предусмотреть возможность задания ненулевых начальных условий и ненулевого
внешнего воздействия.
Программа должна демонстрировать <A HREF="#par_effect">ускорение<A>
по сравнению с последовательным вариантом.
Предусмотреть визуализацию результатов посредством утилиты gnuplot.
<BR><BR>

22<SUP>*</SUP>. Разработать, используя средства многопотокового программирования, параллельную
программу решения уравнения прямоугольной мембраны методом конечных
разностей с использованием <I>неявной</I> вычислительной схемы. Количество потоков,
временной интервал моделирования и количество узлов расчетной сетки -
параметры программы.<BR>
Уравнение мембраны имеет следующий вид:
<P>d<SUP>2</SUP>z/dt<SUP>2</SUP> =
a<SUP>2</SUP>*(d<SUP>2</SUP>z/dx<SUP>2</SUP>+d<SUP>2</SUP>z/dy<SUP>2</SUP>)+f(x,y,t)
<P>, где t - время, x, y - пространственные координаты, z - отклонение (малое) 
точки мембраны от положения
покоя, a - фазовая скорость, f(x,y,t) - внешнее &quot;силовое&quot;
воздействие на мембрану перпендикулярное ее плоскости.<BR>
Предусмотреть возможность задания ненулевых начальных условий и ненулевого
внешнего воздействия.
Программа должна демонстрировать <A HREF="#par_effect">ускорение<A>
по сравнению с последовательным вариантом.
Предусмотреть визуализацию результатов посредством утилиты gnuplot.
<BR>
<I>Примечание.</I> Использование неявной вычислительной схемы
связано с решением системы ЛАУ на каждом временн<B>о</B>м слое.
Следовательно, распараллеливание решения краевой задачи неявным методом
сводится к распараллеливанию решения системы ЛАУ методом Гаусса.
Распараллеливание же метода Гаусса проще всего реализуется в ситуации,
когда матрица коэффициентов системы имеет 
<A HREF="#diag_matrix">блочно-диагональный с окаймлением</A> вид.
Матрица же коэффициентов автоматически получит такой вид, если
нумерацию узлов расчетной сетки вести по такой простой схеме:
сначала &quot;внутренние&quot; узлы всех фрагментов, на которые
разбивается мембрана, а в последнюю очередь -
&quot;соединительные&quot; узлы. Кстати, сказанное выше справедливо
и для метода прогонки (поскольку этот метод - частный случай метода
Гаусса).
См. также <A HREF="#matrix">замечание<A>.
<BR><BR>

23. Разработать программу, моделирующую в реальном времени работу поточной линии,
состоящей из N станков и обрабатывающей заготовки M типов.<BR>
Каждая заготовка
последовательно проходит обработку на всех станках линии. Времена обработки
заготовок каждого типа (в секундах) на каждом станке линии задаются в виде
прямоугольной матрицы размером NxM в конфигурационном файле line.cnf.
Первые 2 строки этого файла содержат числа N и M.<BR>
Программа реализуется N+1 потоком управления. Корневой поток порождает N 
потоков-&quot;станков&quot;, передавая им информацию о временах
обработки заготовок разного типа. Далее этот поток читает со стандартного
ввода последовательность номеров типов заготовок и передает её на вход 
первого потока-&quot;станка&quot;. Потоки-&quot;станки&quot;
имитируют обработку заготовок с помощью функции sleep() и передают
номера типов обработанных заготовок потокам-приёмникам.<BR>
Предусмотреть вывод информации о ходе обработки заготовок.<BR>
Некоторые из возможных модификаций задания:
<UL>
<LI>
обеспечить &quot;псевдографическую&quot; визуализацию хода обработки заготовок
(для этого может понадобиться ещё 1 поток-визуализатор);
</LI>
<LI>
учесть вероятность сбоя в работе каждого станка и выбраковки в следствие этого
заготовок (а что эта вероятность из себя представляет?);
</LI>
<LI>
учесть возможность присутствия между станками буфера хранения заготовок;
</LI>
<LI>
многое др..
</LI>
</UL>

24. Разработать программу, моделирующую в реальном времени работу кооператива
подвижных манипуляторов (ПМ) и блока управления (БУ) ими.<BR>
БУ реализуется в качестве головного (корневого) потока и воспринимает
со стандартного ввода команды создания/уничтожения ПМ и управления ими.
ПМ реализуются в рамках отдельных вновь порождаемых (и убиваемых) потоков. 
ПМ существуют в прямоугольном дискретном поле размером NxM и могут 
передвигаться в нем в 4-х
направлениях с временными затратами T секунд на клетку. При достижении границы
поля ПМ останавливается. ПМ информируют о смене своего положения, например,
выдавая на стандартный вывод (что неправильно, почему?)
строку &quot;кто: откуда=&gt;куда&quot;.<BR>
БУ читает со стандартного ввода команды пользователя (синтаксис придумать
самостоятельно), позволяющие создавать/уничтожать ПМ, задавать их направление
и &quot;скорость&quot; движения (количество ПМ не ограничено).<BR>
Некоторые из возможных модификаций задания:
<UL>
<LI>
обеспечить &quot;псевдографическую&quot; визуализацию передвижения ПМ
(для этого может понадобиться ещё 1 поток-визуализатор);
</LI>
<LI>
реализовать какую-либо стратегию разрешения конфликта при столкновении
ПМ;
</LI>
<LI>
обеспечить &quot;отскакивание&quot; ПМ от границы;
</LI>
<LI>
обеспечить &quot;подбор&quot; некоторых предметов ПМ в поле его деятельности;
</LI>
<LI>
многое др..
</LI>
</UL>

25. Разработать программу, реализующую обработку строк текста и функционирующую в рамках 3-х
потоков управления.<BR>
Поток 0 (корневой) порождает 2-ух потомков (напрямую или опосредованно, решать вам) и
организует передачу строк символов в последовательности
&quot;поток-0 =&gt; поток-1 =&gt; поток-2&quot;.<BR>
Поток 0 получает строку символов латинского алфавита со стандартного ввода и передаёет
ее в неизменном виде потоку 1.<BR>
Поток 1 умеет преобразовывать полученную от потока 0 строку 
символов различными способами:
<UL>
<LI>
трансляция строки в неизменном виде;
</LI>
<LI>
инвертирование строки - первый символ становится последним и т.д.;
</LI>
<LI>
обмен соседних символов - нечетный становится на место четного и наоборот;
</LI>
<LI>
перевод в КОИ-8 - установление в 1 старшего (8-ого) бита каждого символа.
</LI>
</UL>

Поток 2 умеет преобразовывать полученную от потока 1 строку символов следующими способами:
<UL>
<LI>
трансляция строки в неизменном виде;
</LI>
<LI>
перевод всех символов строки в &quot;верхний регистр&quot;;
</LI>
<LI>
перевод всех символов строки в &quot;нижний регистр&quot;;
</LI>
<LI>
смена &quot;регистра&quot; всех символов строки.
</LI>
</UL>
Основная функциональноcть потока 0 - считывание со стандартного ввода строк латинского текста
и передача их (строк) потоку 1. Однако сигнал SIGINT (Ctrl/C) переводит
поток 0 в состояние
<B>однократного</B> чтения со стандартного ввода команды перехода потока 1 или 2 к
новому способу обработки поступающих к нему строк текста (синтаксис команд 
придумать самостоятельно).<BR>
Обязательно обеспечить индикацию результатов работы каждого потока в правильной
врем<B>е</B>нной последовательности.
</LI>
<BR><BR>

26. Разработать программу, реализующую обработку текстовых файлов и функционирующую в рамках 3-х
потоков.<BR>
Корневой поток является управляющим и принимает в качестве аргументов имена 2-х файлов.
В начале своей работы он порождает 2 потока, передавая каждому по одному имени файла.<BR>
Первый порожденный поток осуществляет побайтное считывание файла и вывод с небольшой задержкой
прочитанных байт (по одному на строке) в верхнем регистре на стандартный вывод.<BR>
Второй порожденный поток осуществляет побайтное считывание файла и вывод с небольшой задержкой
прочитанных байт (по одному на строке) в нижнем регистре на стандартный вывод.<BR>
Порожденные потоки функционируют параллельно.<BR>
Управляющий поток считывает со стандартного ввода строки, содержащие имена новых текстовых
файлов и заставляет порожденные потоки <B>немедленно</B> переходить на обработку новых файлов по
следующей схеме: второй порожденный поток переходит к обработке файла, ранее обрабатываемого
первым потоком; первый порожденный поток начинает обрабатывать файл, имя которого
ему передает управляющий поток.
<BR>


<A NAME="matrix">
<H4>Представлении матриц в языке С</H4>

Отмечается повальное использование студентами в программах на языке С
для представления прямоугольных матриц конструкций вида
<PRE>
double matrix[N][M];
</PRE>
где N и M - константы.
<BR>
Этот способ кажется удобным в программировании, поскольку позволяет
адресоваться к элементам матрицы &quot;естественным&quot; способом -
matrix[i][j].
Однако необходимо осознавать, что такому представлению присущ ряд
серьёзных недостатков.
<UL>
<LI>
Размерность матриц должна быть задана в исходном коде программы до
её компиляции.
</LI>
<LI>
Невозможно освободить занимаемую матрицей память в ситуации,
когда её содержимое становится ненужным.
</LI>
<LI>
Работа с двумя индексами матрицы-аргумента в универсальных функциях невозможна
(т.е. конструкция matrix[i][j] в функциях недопустима, поскольку в
момент компиляции размер матрицы неизвестен).
</LI>
</UL>

Поэтому в лабораторных работах рекомендуется для хранения прямоугольных
матриц размером NxM использовать одномерный массив:
<PRE>
double *matrix;
. . .
matrix = (double *) calloc (N*M, sizeof(double));
</PRE>
Для доступа к элементу в i-ой строке и j-ом столбце матрицы применяется
конструкция matrix[M*i+j].

<A NAME="gen_les">
<H4>Генерация тестовой системы ЛАУ</H4>
При невозможности использования готовых матриц коэффициентов
из <A HREF="http://math.nist.gov/MatrixMarket">хранилища</A> матрицу
коэффициентов и вектор правых частей системы ЛАУ можно сгенерировать
самостоятельно по следующей простой схеме.
<OL>
<LI>
Положить равными 1 все элементы вектора неизвестных <B>X</B> (это
впоследствии облегчит контроль правильности решения системы ЛАУ).
</LI>
<LI>
Присвоить всем элементам матрицы коэффициентов <B>A</B> случайные
значения из диапазона, скажем, -1,0 ... 1,0.
</LI>
<LI>
Рассчитать значения всех элементов вектора правых частей <B>B</B> путем
перемножения <B>A</B> и <B>X</B> (при единичном векторе <B>X</B>
перемножение сводится к суммированию элементов строк <B>A</B>).
</LI>
</OL>
<B>Внимание!</B> Размерность генерируемых систем не должна быть
&quot;игрушечной&quot;, количество неизвестных должно превышать 1000.

<A NAME="diag_matrix">
<H4>Система ЛАУ со структированной матрицей коэффициентов</H4>
Матрица называется блочно-диагональной с окаймлением, если она
имеет следующий вид.
<TABLE ALIGN=CENTER BORDER=1 CELLSPACING=0>
<TR ALIGN=CENTER>
<TD><B>A<SUB>11</SUB></B></TD><TD><B>0</B></TD><TD><B>...</B></TD>
<TD><B>0</B></TD><TD><B>A<SUB>1N<SUB></B></TD>
</TR>
<TR ALIGN=CENTER>   
<TD><B>0</B><TD><B>A<SUB>22</SUB></B></TD><TD><B>...</B></TD>
<TD><B>0</B></TD><TD><B>A<SUB>2N<SUB></B></TD>
</TR>    
<TR ALIGN=CENTER>   
<TD><B>...</B></TD><TD><B>...</B></TD><TD><B>...</B></TD>
<TD><B>...</B></TD><TD><B>...</B></TD>
</TR>    
<TR ALIGN=CENTER>   
<TD><B>0</B></TD><TD><B>0</B></TD><TD><B>...</B></TD>
<TD><B>A<SUB>N-1,N-1</SUB></B></TD><TD><B>A<SUB>N-1,N<SUB></B></TD>
</TR>    
<TR ALIGN=CENTER>   
<TD><B>A<SUB>N1</SUB></B></TD><TD><B>A<SUB>N2</SUB></B></TD><TD><B>...</B></TD>
<TD><B>A<SUB>N,N-1</SUB</B></TD><TD><B>A<SUB>NN<SUB></B></TD>
</TR>    
</TABLE>

Решение методом Гаусса системы ЛАУ с матрицей коэффициентов такой структуры
может быть легко распараллелено.<BR>
Во-первых, очевидно, что независимо 
друг от друга может быть выполнено приведение к верхнетреугольному 
виду в прямом ходе Гаусса диагональных
блоков <B>A<SUB>11</SUB></B> ... <B>A<SUB>N-1,N-1</SUB></B> во всех
горизонтальных лентах матрицы (кроме последней).<BR>
Во-вторых, параллельно (и это менее очевидно) может быть выполнено
исключение элементов блоков нижнего окаймления 
<B>A<SUB>N1</SUB></B> ... <B>A<SUB>N,N-1</SUB></B> 
в том же прямом ходе Гаусса.<BR>
В-третьих, очевидно, что после прямого и обратного хода Гаусса по самой нижней
ленте системы ЛАУ, возможно независимое выполнение обратного хода
по каждой оставшейся ленте.

<A NAME="par_effect">
<H4>Эффект от распараллеливания</H4>

Параллельные программы, предназначенные для решения вычислительных задач
(систем алгебраических и дифференциальных уравнений), должны
продемонстрировать сокращение времени решения.<BR>
Для этого, во-первых, необходимо замерять время выполнения программ. Здесь
полезной может оказаться команда time (1). Однако эта команда выдаёт время
выполнения программы целиком, нас же больше интересует &quot;чистое&quot;
время решения без накладных расходов, связанных с генерацией тестовых
матриц, вводом-выводом, подготовкой данных для gnuplot и т.п. Поэтому для
определения времени исполнения отдельных этапов вычислительного процесса
имеет смысл использовать функцию gettimeofday, обеспечивающую точность
замера в 1 мкс. Кроме того удобно обложить #ifdef'ами все фрагменты текста
программы, не связанные непосредственно с целевыми вычислениями.<BR>
Во-вторых, для выявления эффекта от распараллеливания необходимо кроме
параллельной версии программы иметь и последовательный вариант. В некоторых
заданиях (например, связанных с МКР) запуск программы в рамках одного потока
или одного процесса MPI даёт временные затраты почти сопоставимые с
затратами последовательной версии. В других (в первую очередь это относится
к решению системы ЛАУ с блочно-диагональной матрицей коэффициентов)
последовательную версию программы приходиться создавать специально. При
многопотоковом программировании параллельная программа легко превращается в
последовательную просто поочерёдным запуском потоков, в случае же
MPI-программы ситуация более сложная.<BR>
<B>Внимание.</B> Существует тонкий момент в оценке эффекта от
распараллеливания при решении системы ЛАУ с блочно-диагональной матрицей
коэффициентов. Дело в том, что увеличение (напр., удвоение) количества
параллельно исполняемых потоков/процессов приводит к уменьшению 
количества элементов в диагональных блоках (в 4 раза), а, следовательно,
и к уменьшению общего числа ненулевых элементов в матрице коэффициентов.
А это снижение общего числа ненулевых элементов само по себе (без учёта
параллельности) обеспечивает ускорение решения (в идеале, в 4 раза).
<BR>
<A NAME="report">
<H4>Содержание отчета</H4>
<UL>
<LI>Текст задания на лаб. работу.</LI>
<LI>Описание структуры программы и реализованных способов взаимодействия
потоков управления (с рисунком).</LI>
<LI>Описание основных используемых структур данных.</LI>
<LI>Блок-схема программы согласно ГОСТ и пояснения к ней.</LI>
<LI>Примеры результатов работы программы.</LI>
<LI>Текст программы с исчерпывающими комментариями.</LI>
</UL>

</BODY>
</HTML>
